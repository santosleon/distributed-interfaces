import { ModelField, RelationField } from '../../grammar/base.interfaces.js'
import { GoModelField } from './go.interfaces.js'

export const DO_NOT_EDIT = `//
// Code generated by distributed_interfaces DO NOT EDIT.
//
// WARNING: Changes to this file may cause incorrect behavior
// and will be lost if the code is regenerated
//`

export const typesMap = {
  'bool':     'bool',

  'int':      'int64',
  'int8':     'int8',
  'int16':    'int16',
  'int32':    'int32',
  'int64':    'int64',

  'uint':     'uint64',
  'uint8':    'uint8',
  'uint16':   'uint16',
  'uint32':   'uint32',
  'uint64':   'uint64',

  'float':    'float64',
  'float32':  'float32',
  'float64':  'float64',

  'date':     'int64',

  'string':   'string',

  'bytes':    '[]byte',
}

export const importMap = {
  'time.Time': 'time',
  'uuid.UUID': 'github.com/google/uuid',
  'json.RawMessage': 'encoding/json',
}

export const snakeToPascal = (input: string): string => {
  return input.toLowerCase().replace(/(?:^|_)(\w)/g, (_, letter) => letter.toUpperCase());
}

export const pascalToSnake = (input: string): string => {
  return input.replace(/(?:^|\.?)([A-Z])/g, (match, group) => `_${group.toLowerCase()}`).replace(/^_/, "");
}

export const getMaxLength = (strArr: string[]) => {
  if(!strArr.length) return 0;
  return strArr.reduce((prev, current) => {
    return prev.length > current.length ? prev : current;
  }).length;
}

export const makeGoType = (field: ModelField) => {
  const pointerStr = (field.isUnique || field.isPrimaryKey || field.isBasicField) ? '' : '*';
  return `${pointerStr}${typesMap[field.type as keyof typeof typesMap]}`;
}

export const makeGoFieldName = (field: ModelField | RelationField): string => {
  if((field as ModelField).isBasicField) {
    let fieldName = snakeToPascal(field.name.substring(1));
    if (fieldName.endsWith("Id")) fieldName = fieldName.slice(0,-2) +"ID";
    return fieldName + '_';
  } else if((field as RelationField).isRelationId) {
    let fieldName = snakeToPascal(field.name);
    return fieldName +'_';
  } else {
    let fieldName = snakeToPascal(field.name);
    if (fieldName.endsWith("Id")) fieldName = fieldName.slice(0,-2) +"ID";
    return fieldName;
  }
}

export const makeModelFieldComplement = (field: ModelField) : GoModelField => {
  return {
    ...field,
    complement: {
      goType: makeGoType(field),
      goFieldName: makeGoFieldName(field),
    },
  };
}
